#!/bin/bash
# lowsars-commander: resource manager for lowsars
# Copyright Â© 2007 Yu Hang, released under GNU General Public License Version 2 or later

show_version(){ echo "lowsars-commander 0.2.0 alpha"; }
#changelog:
#0.2.0 alpha this is the first version
show_usage(){
echo "Usage: $commandername [--] [RESOURCELIST]...
  -s, --automatic-stop      stop if all the resources are returned
  -n, --no-file             do not use files other than fd
      --help                display this help and exit
      --version             output version information and exit
the resourcelist format: type[*[number]][{resourcelist}][;resourcelist]
number is 1 by default, but if only a * character is specified, it means a
  infinite number of this resource
each time, $commandername will put one dot character in stdout, and read a
  single line from input, with format [scope.]...[path//|pid[/fd]]command
scope can contain anything except ., / and the following commands, alphanumerics
  are recommended, path must begin with /, fd is 9 if not specified
command is one of the following:
      +resourcelist         request this type of resource, wait if unavailable
      ?resourcelist         request resource, break if unavailable
      =resourcelist         repeatedly request resource with highest priority
      %[prefix]             give failure to each request with this scope
      @[prefix]             return a random unused scope or subscope name
      *resourcelist         cancel a +,= or % command
      -resourcelist         release or add resource
      #                     do nothing, return = when this command is parsed
      :number               do the command in the next line number times
      {                     read more commands, one per line, until a matching }
                              character found in the beginning of a line, the }
                              character can be followed by another command
      [                     same as above but the matching character is ], and
                              do not assign other waited resources until all
                              commands read
      (                     same as above but the matching character is ), and
                              do not assign any resources until everything done
a blank line terminates the session
if SIGTERM is captured, it is equal to command % and set -s
SIGUSR1 and SIGUSR2 will set and unset -s option
$commandername will write one of the following to the specified path or fd:
      +resourcelist         request ok, returning the requested resource
      ?                     resource not available and not waited
      =resourcelist         responce of a repeated request
      =                     +, =, % or # command is accepted
      %                     a = command is broke by %
      @scope                return the @ result
      *resourcelist         request canceled
      -                     resource accepted
      #                     illegal command
      :                     : or brackets accepted, ready for the next commands
      :number               closing brackets accepted, number brackets or : left"
}

automaticstop=0
trap automaticstop=1 usr1
trap automaticstop=0 usr2
enablefile=1

defaultfd=9
spechars="+-?=%@*#:{}[]()"

endoption=0

if [ "$0" = "`which -- \`basename -- "$0"\``" ]
  then commandername="`basename -- "$0"`"
  else commandername="$0"; fi

err_unrecog(){
echo "$commandername: unrecognized option \`$param'"
exit 2
}

err_argreq(){
echo "$commandername: option \`$param' requires an argument"
exit 2
}

while if [ "$endoption" = "1" ]||{
  [ "${!OPTIND}" = "--" ]&&endoption=1; ! getopts :sz-: param;}
  then param=""; arg=${!OPTIND}; ((OPTIND++<=$#))
  elif [ "$param" = "-" ]; then
    param="--${OPTARG%%=*}"
    arg="`[ "$param" = "--$OPTARG" ]||echo ${OPTARG#*=}=`";:
  else param="-$param"; arg="$OPTARG=";:; fi; do
  #mainly copied from lowsars-test
  case "$param" in
    --help)show_usage;exit 0;;
    --version)show_version;exit 0;;
    -s|--automatic-stop)automaticstop=1;;
    -n|--no-file)enablefile=0;;
    -\?)err_unrecog;;
    -:)err_argreq;;
    --*|-*)err_unrecog;;
    "")addres "$arg";;
  esac
done

get_varname(){
#get_varname string[@]
resultstr=()
for varnameitem; do
{ resultstr[${#resultstr[@]}]="
`od -vtx1 -N "${#varnameitem}"` ";} <<<"$varnameitem"
done
local IFS=_
{ resultstr=("`cut -b 9-`");} <<<"${resultstr[*]}"
resultstr="${resultstr//[
\ ]}"
}

#namespace: lowsars_db_avail_$resultstr: available; lowsars_db_count_$resultstr: all
#  (?) lowsars_db_total_$resultstr: all subs
#  lowsars_db_query_$resultstr: queried; lowsars_db_query(): queries

db_clean(){
unset "${!lowsars_db_@}"
}

db_add(){
get_varname "$@"
((++lowsars_db_avail_$resultstr>lowsars_db_count_$resultstr&&lowsars_db_count_$resultstr=lowsars_db_avail_$resultstr))
}

db_query(){
get_varname "$@"
if ((lowsars_db_avail_$resultstr))
  then queryresult="$resultstr"
elif
"${!lowsars_db_avail_$resultstr_@}"

}


while echo -n .; IFS=; read -r; do
  prefix=".${REPLY%%["$spechars/"]*}"
  IFS=.
  scope=($prefix)
  commandchar="${REPLY:${#prefix}-1:1}"
  commandcontent="${REPLY:${#prefix}}"
  file=
  if [ "${prefix: -1}" = "." ]
    then [ "$commandchar" = "/" ]&&{
      [ "$enablefile" = "0" ]&&continue
      file="/${commandcontent%%//*}"
      commandchar="${commandcontent:${#file}+1:1}"
      commandcontent="${commandcontent:${#file}+2}"
    }
  elif pid="${scope[${#scope[@]}-1]}"; unset scope[${#scope[@]}-1]
    [ "$pid" -eq "$pid" ] 2>/dev/null||continue
    #test if it is an integer, hexadecimal not supported, sorry
    ((pid=pid))
    #convert to decimal
    [ "$commandchar" = "/" ]
    then fd="${commandcontent%%[!0-9]*}"
      [ "$fd" -eq "$fd" ] 2>/dev/null||continue
      ((fd=fd))
      file="/proc/$pid/fd/$fd"
      commandchar="${commandcontent:${#fd}:1}"
      commandcontent="${commandcontent:${#fd}+1}"
    else file="/proc/$pid/fd/$defaultfd"
  fi
  brackets=()
  cache=()
  cacheind=0
  repeatcount=0
  disablecount=0
  justread=1
  excludecount=0
  while [ "$commandchar" != "" ]&&{
    scopebegin=0
    case "$commandchar" in
      "+")((disablecount))||request_wait $commandcontent;;
      "?");;
      "=");;
      "%");;
      "@");;
      "*");;
      "-");;
      "#");;
      ":")if ! [ "$commandcontent" -eq "$commandcontent" ] 2>/dev/null
          then echo "#" >>"$file"
        elif ((justread))&&echo ":" >>"$file"; scopebegin=1
          ((disablecount?commandcontent=0:commandcontent>1))
          then brackets[${#brackets[@]}]="$commandcontent:$cacheind"
            ((repeatcount++))
        elif ((commandcontent<=0))
          then brackets[${#brackets[@]}]="0:-"; ((disablecount++))
          else brackets[${#brackets[@]}]="1:+"
        fi;;
      "{")brackets[${#brackets[@]}]="}"; ((justread))&&echo ":" >>"$file";;
      "[")brackets[${#brackets[@]}]="]"; ((excludecount++,justread))&&echo ":" >>"$file";;
      "(");;
      "}"|"]"|")")if ((${#brackets[@]}))&&[ "${brackets[${#brackets[@]}-1]}" = "$commandchar" ]
        then unset brackets[${#brackets[@]}-1]
          [ "$commandchar" = "]" ]&&((excludecount--))
          ((justread))&&echo ":${#brackets[@]}" >>"$file"
        else echo "#" >>"$file"
        fi;;
      #"")continue;;
      *)[ "$file" = "" ]||echo "#" >>"$file";;
    esac
    [ "$scopebegin" = "0" ]&&while [ "${#brackets[@]}" != "0" ]&&[ "${brackets[${#brackets[@]}-1]:0:2}" = "0:" ]; do
      case "${brackets[${#brackets[@]}-1]: -1}" in
        "-")((disablecount--));;
        "+");;
        *)((repeatcount--));;
      esac
      unset brackets[${#brackets[@]}-1]
    done
    [ "${#brackets[@]}" != "0" ]
    }
  do
    t="${brackets[${#brackets[@]}-1]##*:}"
    case $t in
      \-|"${brackets[${#brackets[@]}-1]}");;
      *)[ "$t" = "+" ]||cacheind=$t
      brackets[${#brackets[@]}-1]="$((${brackets[${#brackets[@]}-1]%:*}-1)):$t";;
    esac
    if ((justread=cacheind>=${#cache[@]})); then
      IFS=
      read -rn 1 commandchar
      [ "$commandchar" = "" ]||read -r commandcontent
      [ "$repeatcount" = "0" ]||[ "$disablecount" != "0" ]||cache[cacheind++]="$commandchar$commandcontent"
    else
      commandchar="${cache[cacheind]:0:1}"
      commandcontent="${cache[cacheind]:1}"
      #BASH BUG: in cache[cacheind++]:1, ++ is calculated before that one more time
      ((cacheind++))
    fi
  done
done

exit 0

